# 引入 consul 原因

ocelot 它本身不具备健康检查 的功能,所以考虑引入 consul

# 形成代码后，调试遇到很多问题

# 首先是 api1 2 服务无法注册到 consul 上

check 地址填错等原因，
然后是缺少 app.MapHealthChecks("/HealthCheck");这个代码 （待查）

# 然后遇到访问 https://localhost:5206/WeatherForecast 这个 代理地址，报出了 找不到 Web 地址对应的网页: https://localhost:5206/WeatherForecast HTTP ERROR 404

原因是代码里缺少
Program.cs
app.UseOcelot(); 这个关键代码

# 然后报的错误是 Error connecting to downstream service, exception: System.Net.Http.HttpRequestException: 由

于目标计算机积极拒绝，无法连接。 (desktop-svpkuf8:5204)
---> System.Net.Sockets.SocketException (10061): 由于目标计算机积极拒绝，无法连接。

主机名解析问题：

- Ocelot 从 Consul 获取的服务地址是 desktop-svpkuf8（您的计算机名）

- 但网关无法解析这个主机名或访问该地址

服务绑定问题：

- 您的 API 服务可能只绑定到 localhost，而不是所有网络接口

- 因此只能通过 localhost 访问，不能通过计算机名访问

##

为此，修改了 api 服务的地址 为"Urls": "https://+:5205",

# 错误又变了 ConnectionToDownstreamServiceError: Error connecting to downstream service, exception: System.Net.Http.HttpRequestException: The SSL connection could not be established, see inner exception.

       ---> System.Security.Authentication.AuthenticationException: The remote certificate is invalid according to the validation procedure: RemoteCertificateNameMismatch

然后在网关中引入了类:
BypassCertificateValidationHandler.cs

```
public class BypassCertificateValidationHandler : DelegatingHandler
{
    protected override async Task<HttpResponseMessage> SendAsync(
        HttpRequestMessage request, CancellationToken cancellationToken)
    {
        // 确保所有请求都使用 localhost
        var uriBuilder = new UriBuilder(request.RequestUri);
        uriBuilder.Host = "localhost"; // 强制使用 localhost
        request.RequestUri = uriBuilder.Uri;

        var handler = new HttpClientHandler
        {
            ServerCertificateCustomValidationCallback = (msg, cert, chain, errors) => true
        };

        using (var httpClient = new HttpClient(handler))
        {
            // 复制请求头
            foreach (var header in request.Headers)
            {
                httpClient.DefaultRequestHeaders.TryAddWithoutValidation(header.Key, header.Value);
            }

            return await httpClient.SendAsync(request, cancellationToken);
        }
    }
}
```

然后 program.cs 修改:

```
    builder.Services.AddOcelot()
    .AddConsul()
    .AddDelegatingHandler<BypassCertificateValidationHandler>(true);
```

# 此时访问网关 地址，是没有问题了(但是仍然不理解其中原理)

https://localhost:5206/test

# 学习：

# 好，多谢你的帮助了，我现在能够通过网关地址访问 url 了，我现在需要梳理一下问题 1.你提到了，把服务注册到 consul 时候设定的 TLSSkipVerify = true, // 跳过证书验证这个，我觉得这个设置是跟服务注册到 consul 相关的设置呀，跟我访问网关地址然后转发到 api 服务器不成功是不是没有什么关系

TLSSkipVerify = true 只影响 Consul 的健康检查行为

![alt text](<截图/0. HealthCheck_TLS.png>)

- TLSSkipVerify 作用：仅控制 Consul 如何验证 API 服务的健康检查端点
- 不影响：Ocelot 网关与 API 服务之间的实际通信

# 其中的不解

嗯，是的，按照你之前给的 方案，我做出了一些改动，但是我遇到了证书的问题，错误是，ConnectionToDownstreamServiceError: Error connecting to downstream service, exception: System.Net.Http.HttpRequestException: The SSL connection could not be established, see inner exception.

       ---> System.Security.Authentication.AuthenticationException: The remote certificate is invalid according to the validation procedure: RemoteCertificateNameMismatch

引入了类:

BypassCertificateValidationHandler.cs

```
public class BypassCertificateValidationHandler : DelegatingHandler
{
    protected override async Task<HttpResponseMessage> SendAsync(
        HttpRequestMessage request, CancellationToken cancellationToken)
    {
        // 确保所有请求都使用 localhost
        var uriBuilder = new UriBuilder(request.RequestUri);
        uriBuilder.Host = "localhost"; // 强制使用 localhost
        request.RequestUri = uriBuilder.Uri;

        var handler = new HttpClientHandler
        {
            ServerCertificateCustomValidationCallback = (msg, cert, chain, errors) => true
        };

        using (var httpClient = new HttpClient(handler))
        {
            // 复制请求头
            foreach (var header in request.Headers)
            {
                httpClient.DefaultRequestHeaders.TryAddWithoutValidation(header.Key, header.Value);
            }

            return await httpClient.SendAsync(request, cancellationToken);
        }
    }
}
```

然后 program.cs 修改:

```
    builder.Services.AddOcelot()
    .AddConsul()
    .AddDelegatingHandler<BypassCertificateValidationHandler>(true);
    然后 服务地址我也改了一下，"Urls": "https://+:5204",  localhost变成了+。
    然后我这里能够工作了。
    但是我并不理解其中的原因，你提到了，Consul 返回的服务地址是计算机名（如 desktop-svpkuf8:5204）那就是说我的api服务注册到consul的地址其实是https://desktop-svpkuf8:5204 这样子的，那为什么加了BypassCertificateValidationHandler.cs的配置，会工作呢，我不懂
```

# 你给出的原因

```
3. 证书问题的真实原因
您遇到的 RemoteCertificateNameMismatch 错误发生在 Ocelot → API 服务 的连接阶段，根本原因是：

Consul 返回的服务地址是计算机名（如 desktop-svpkuf8:5204）

API 服务的 HTTPS 证书只对 localhost 有效

Ocelot 尝试访问 https://desktop-svpkuf8:5204/api/test 时：

证书验证失败（证书是为 localhost 颁发的）

出现名称不匹配错误
```

## 流程解析

1. 服务注册到 Consul

![alt text](<截图/1. 服务注册到 Consul.png>)

2. Ocelot 获取服务信息
   ![alt text](<截图/2. Ocelot 获取服务信息.png>)

3. 原始请求流程（失败）
   ![alt text](<截图/3. 原始请求流程（失败）.png>)
4. 使用 BypassHandler 后的流程（成功）

![alt text](<截图/4. 使用 BypassHandler 后的流程（成功）.png>)

### 关键点解析

1. 地址重写的作用

```
var uriBuilder = new UriBuilder(request.RequestUri);
uriBuilder.Host = "localhost"; // 关键修改
request.RequestUri = uriBuilder.Uri;
```

转换前：https://desktop-svpkuf8:5204/api/test

转换后：https://localhost:5204/api/test

这样做的意义：

- 使请求地址与证书的有效域名(localhost)匹配

- 避开了计算机名解析问题

2. 为什么使用 + 绑定有效

- 表示"绑定到所有网络接口和主机名"

效果：

- 服务同时监听 localhost、127.0.0.1、desktop-svpkuf8 等

- 因此能接受来自不同主机名的请求

### 完整工作流程图解

![alt text](<截图/5. 完整工作流程图解.png>)

# 疑问

好嘞，在 consul 上得到的服务地址是 机器名字哈 desktop-svpkuf8 这个形势，但是呢我要说，我的 api 服务注册的是 localhost 呀，我把核心代码发给你，appsettings.Development.json {
"Urls": "https://+:5204",
"Logging": {
"LogLevel": {
"Default": "Information",
"Microsoft.AspNetCore": "Warning"
}
},
"Consul": {
"ServiceScheme": "https",
"ServiceName": "ServiceName",
"ServiceAddress": "localhost",
"ServicePort": 5204
}
}
加载配置文件代码是 builder.Services.Configure<ConsulConfig>(builder.Configuration.GetSection("Consul")); 注册到 consul 代码是
using Consul;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Options;

public class ConsulRegistrationService : IHostedService
{
private readonly IConsulClient \_consulClient;
private readonly ConsulConfig \_consulConfig;
private readonly ILogger<ConsulRegistrationService> \_logger;
private string \_serviceId;

    public ConsulRegistrationService(
        IConsulClient consulClient,
        IOptions<ConsulConfig> consulConfig,
        ILogger<ConsulRegistrationService> logger)
    {
        _consulClient = consulClient;
        _consulConfig = consulConfig.Value;
        _logger = logger;
    }

    public async Task StartAsync(CancellationToken cancellationToken)
    {
        _serviceId = $"{_consulConfig.ServiceName}-{Guid.NewGuid()}";

        var healthCheck = $"{_consulConfig.ServiceScheme}://{_consulConfig.ServiceAddress}:{_consulConfig.ServicePort}/HealthCheck";

        var serviceName = _consulConfig.ServiceName;

        Console.WriteLine($"Registering service {serviceName} with ID {_serviceId} at {healthCheck}");

        var registration = new AgentServiceRegistration
        {
            ID = _serviceId,
            Name = _consulConfig.ServiceName,
            Address = _consulConfig.ServiceAddress,
            Port = _consulConfig.ServicePort,
            Check = new AgentServiceCheck
            {
                HTTP = healthCheck,
                Interval = TimeSpan.FromSeconds(10),
                Timeout = TimeSpan.FromSeconds(5),
                DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(30),
                //TLSSkipVerify = true, // 跳过证书验证
            }
        };

        await _consulClient.Agent.ServiceRegister(registration, cancellationToken);
        _logger.LogInformation($"Service {_consulConfig.ServiceName} registered with Consul");
    }

    public async Task StopAsync(CancellationToken cancellationToken)
    {
        await _consulClient.Agent.ServiceDeregister(_serviceId, cancellationToken);
        _logger.LogInformation($"Service {_consulConfig.ServiceName} deregistered from Consul");
    }

}

public class ConsulConfig
{
public string ServiceName { get; set; } = "service-name";
public string ServiceAddress { get; set; } = "localhost";
public int ServicePort { get; set; } = 5000;
public string ServiceScheme { get; set; } = "http";
}，这里面 Address = \_consulConfig.ServiceAddress, 肯定会是 localhost，那我想知道我在 consul 的 页面上看 service 中 instance 信息中 NodeName
DESKTOP-SVPKUF8 写的数主机名字，难道 consul 注册的其实是 localhost，只是 consul 的页面上显示成了计算机名字呢，然后我之前遇到的错误中提示的信息你额，你看哈 于目标计算机积极拒绝，无法连接。 (desktop-svpkuf8:5204)
---> System.Net.Sockets.SocketException (10061): 由于目标计算机积极拒绝，无法连接。
这里是 计算机名字，

### 您的观察非常准确，这里涉及到 Consul 的工作原理和一些隐藏行为

1. 您在代码中明确注册的是 localhost：
   Address = \_consulConfig.ServiceAddress // = "localhost"
2. 但错误信息显示连接的是 desktop-svpkuf8:5204
   由于目标计算机积极拒绝，无法连接。 (desktop-svpkuf8:5204)
3. Consul UI 显示节点名为计算机名：
   这是 Consul 的默认行为

### 为什么错误信息显示计算机名

DNS 解析行为：

Ocelot 获取到的是 Node.Address (如 192.168.1.100)

在错误处理中，.NET 尝试反向解析 IP 得到主机名 DESKTOP-SVPKUF8

## 解决方案为什么有效

![alt text](<截图/6. 解决方案为什么有效.png>)

# 疑问

好现在呢，我的错误信息为什么显示成了 主机名字，我已理解，其实呢，注册的服务依然是 localhost 的，只是 错误解析时候给解析成了主机名字。现在我需要理解解决方案为什么有效，如果我没有添加 bypasshandler，那网关默认发送的请求 就是 https://desktop-svpkuf8:5204/api/test 这个地址的请求了吗，然后无法解析吗

## 没有 BypassHandler 时的默认流程

![alt text](<截图/7. 没有 BypassHandler 时的默认流程.png>)

1. Consul 返回的是 Node.Address：

这是机器的实际 IP 地址（如 192.168.1.100）

不是您注册的 ServiceAddress (localhost)

2. Ocelot 使用 Node.Address 构造请求：

```
var service = consulClient.GetService("ServiceName");
var url = $"https://{service.Node.Address}:{service.Service.Port}/api/test";
```

3. 证书验证失败

API 服务的证书是为 localhost 签发的

请求发往 192.168.1.100（或反向解析的 desktop-svpkuf8）

触发 RemoteCertificateNameMismatch 错误

## 为什么错误显示为计算机名

![alt text](<截图/8. 为什么错误显示为计算机名.png>)

## BypassHandler 如何解决问题

![alt text](<截图/9. BypassHandler 如何解决问题.png>)
两个关键操作：

1. 地址重写：

```
uriBuilder.Host = "localhost"; // 关键修改
```

- 将 https://192.168.1.100:5204 → https://localhost:5204

- 使请求地址与证书的 CN 名称匹配

2. 禁用证书验证：

```
   ServerCertificateCustomValidationCallback = (msg, cert, chain, errors) => true
```

即使证书有其他问题也允许连接

在开发环境中安全，因为通信仍在 TLS 加密通道

# 完整的 bypasshandler 解决方案

![alt text](<截图/10. 完整的bypasshandler解决方案.png>)
关键步骤解析

1. 客户端发起请求 (步骤 1)
   用户访问网关地址：https://localhost:5206/test

2. Ocelot 服务发现 (步骤 2-5)
   Ocelot 根据路由配置，需要找到 "ServiceName" 的服务

向 Consul 查询可用实例 3. Consul 响应 (步骤 4)

```
{
  "Service": {
    "Service": "ServiceName",
    "Address": "localhost",  // 您注册的 ServiceAddress
    "Port": 5204
  },
  "Node": {
    "Node": "DESKTOP-SVPKUF8",
    "Address": "192.168.1.100"  // 实际网络地址
  }
}
```

关键点：Consul 返回两个地址信息：

ServiceAddress: 服务自身标识 (localhost)

Node.Address: 节点网络地址 (192.168.1.100)

4. Ocelot 的默认行为 (步骤 6)

- Ocelot 默认使用 Node.Address + Service.Port 构建请求：
  https://192.168.1.100:5204/api/test

- 这就是为什么错误信息中显示计算机名：

.NET 会将 192.168.1.100 反向解析为 desktop-svpkuf8

5. BypassHandler 的转换 (步骤 7-9)

```
// 原始请求: https://192.168.1.100:5204/api/test
var uriBuilder = new UriBuilder(request.RequestUri);
uriBuilder.Host = "localhost"; // 修改为 https://localhost:5204/api/test
request.RequestUri = uriBuilder.Uri;
```

6. API 服务的接受能力 (步骤 10-11)
   // appsettings.json
   "Urls": "https://+:5204"

- +表示监听所有网络接口：

  127.0.0.1 (localhost)

  192.168.1.100 (实际 IP)

::1 (IPv6)

- 因此能接受转换后的请求

7. Consul 健康检查 (独立流程)
   使用您注册的 ServiceAddress (localhost)

不受 Ocelot 请求影响

# 生产环境的情况，我们之后再讨论哈，我们还是聚焦在 我现在的开发环境的问题上，我想问一下 class BypassCertificateValidationHandler : DelegatingHandler 这个 类，他的调用时机

DelegatingHandler 在 Ocelot 中的位置:
![alt text](<截图/11.  DelegatingHandler 在 Ocelot 中的位置.png>)
BypassCertificateValidationHandler 的精确调用时机:
![alt text](<截图/12. BypassCertificateValidationHandler 的精确调用时机.png>)

# 生产环境配置在看了。。

回到 userservice 工程继续开发
