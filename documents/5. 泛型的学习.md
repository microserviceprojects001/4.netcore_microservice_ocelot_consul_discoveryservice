# 格外需要学习的是泛型方法使用原则

一个方法是泛型方法，那方法体上必须要有<T>
例如：

```
private async Task<HttpResponseMessage> DoPostAsync1<T>(
          T item,
           HttpMethod method,
           string url,
           Func<HttpRequestMessage> requestMessageFunc,
           string authorizationToken,
           string requestid = null,
           string authorizationMethod = null)
    {
        return new HttpResponseMessage();
    }
```

调用方可以省略写法 无需指定<T>
例如：

```
 public async Task<HttpResponseMessage> PostAsync<T>(
        string url,
        T item,
        string authorizationToken = null,
        string requestid = null,
        string authorizationMethod = "Bearer")
    {
        Func<HttpRequestMessage> requestMessageFunc = () => CreateRequestMessage<T>(HttpMethod.Post, url, item);
        return await DoPostAsync1(item, HttpMethod.Post, url, requestMessageFunc, authorizationToken, requestid, authorizationMethod);
    }
```

如果被定义了 DoPostAsync1<T>()， 参数中不带有 T，那调用方必须指定 await DoPostAsync1<T> 因为编译器无法推断出 T 是谁
但是这么弄，也失去了意义，T 既然没有使用，那定义成泛型方案也没有意义了

# 泛型参数方法的使用原则

，核心原则与单参数相同，但有一些额外的注意事项
调用规则与类型推断

规则 1：所有参数都能推断 → 可完全省略类型参数

```

// 多泛型参数方法示例
public TResult Process<TInput, TResult>(
    TInput input,
    Func<TInput, TResult> transformer)
{
    return transformer(input);
}


// 编译器能推断所有类型
string result = Process(10, n => n.ToString());
// TInput = int, TResult = string
```

规则 2：部分参数能推断 → 必须显式指定无法推断的类型

```
// 定义
TResult Convert<TValue, TResult>(TValue value)
    => (TResult)Convert.ChangeType(value, typeof(TResult));

// 调用 - 必须指定 TResult
double result = Convert<int, double>(10);
// ↑ TValue 可推断，但 TResult 必须显式指定
```

规则 3：无参数能推断 → 必须显式指定所有类型

```
// 定义
Tuple<T1, T2> CreateTuple<T1, T2>() => new Tuple<T1, T2>();

// 调用 - 必须指定所有类型
var tuple = CreateTuple<int, string>();
```

# 最佳实践与设计原则

1. 参数顺序优化（重要！）

```
// ✅ 推荐：可推断类型在前
void Save<TEntity, TContext>(TEntity entity, TContext context) {...}

// 调用更简洁
Save(product, dbContext); // 自动推断 TEntity=Product, TContext=DbContext
```

2. 为每个类型参数添加约束

```
// 添加约束提高类型安全
TResult Parse<TInput, TResult>(TInput input)
    where TInput : IConvertible
    where TResult : struct
{
    return (TResult)Convert.ChangeType(input, typeof(TResult));
}

```

3. 避免超过 3 个类型参数

```
// ❌ 不易维护
- void Process<T1, T2, T3, T4>(T1 a, T2 b, T3 c, T4 d) {...}

// ✅ 重构为类
+ class Processor<T1, T2>
+ {
+     void Execute(T3 c, T4 d) {...}
+ }
```

# 我们还是已数据库 取数据为例，比方说我数据 User 表有一个字段但是 age 年龄，但是可能是空的所以我在定义对应表的 Entity 时候 Class User { public int？ age} 这样比较好吗，这样取数据库数据的时候可以方便的赋值了

```
public static class DataReaderExtensions
{
    // 值类型可空版本
    public static T? GetNullable<T>(this IDataRecord r, int i) where T : struct
    {
        return r.IsDBNull(i) ? null : (T?)r.GetValue(i);
    }

    // 引用类型版本
    public static T Get<T>(this IDataRecord r, int i) where T : class
    {
        return r.IsDBNull(i) ? null : (T)r.GetValue(i);
    }

    // 基本类型快捷方式（非空值）
    public static int GetInt32(this IDataRecord r, int i)
    {
        return r.GetInt32(i);
    }
}

// 使用示例
var user = new User
{
    Id = r.GetInt32(0),          // 非空值类型
    Name = r.Get<string>(1),      // 引用类型（可空）
    Age = r.GetNullable<int>(2),  // 可空值类型
    Avatar = r.Get<byte[]>(3)     // 引用类型（可空）
};


```

```

// 或者使用原生ADO.NET
public User ReadUser(IDataRecord reader)
{
    return new User
    {
        Id = reader.GetInt32(0),
        Name = reader.GetString(1),
        Age = reader.GetNullable<int>(2),               // 可空值类型
        RegistrationDate = reader.GetNullable<DateTime>(3), // 可空日期
        CreditScore = reader.GetNullable<decimal>(4),   // 可空小数
        IsVerified = reader.GetNullable<bool>(5)        // 可空布尔
    };
}

public class User
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;

    // 可空值类型字段 - 完美匹配数据库中的NULL
    public int? Age { get; set; }

    // 其他可能为空的字段
    public DateTime? RegistrationDate { get; set; }
    public decimal? CreditScore { get; set; }
    public bool? IsVerified { get; set; }

    // 引用类型字段（默认可为空）
    public string? Email { get; set; }
    public byte[]? ProfilePicture { get; set; }
}
```
